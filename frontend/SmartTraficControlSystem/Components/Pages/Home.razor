@page "/"
@using SmartTraficControlSystem.Components.Services
@using SmartTraficControlSystem.Utilities.Models
@inject SensorService sensorService
@inject MqttService mqttService
<MudContainer MaxWidth="MaxWidth.False" Class="pa-4">
    <MudGrid>

        <!-- Flow Stats -->
        <MudItem xs="12" md="4">
            <MudPaper Elevation="4" Class="pa-4 d-flex flex-column justify-space-between" Style="height:100%">
                <MudText Typo="Typo.h5">Pedestrian green light duration</MudText>
                <MudText Typo="Typo.h6" Class="mt-2">@($"{averagePedestrianDuration:F2}/s Average pedestrian green light duration")</MudText>
            </MudPaper>
        </MudItem>

        <MudItem xs="12" md="4">
            <MudPaper Elevation="4" Class="pa-4 d-flex flex-column justify-space-between" Style="height:100%">
                <MudText Typo="Typo.h5">Vehicle green light duration</MudText>
                <MudText Typo="Typo.h6" Class="mt-2">@($"{averageVehicleDuration:F2}/s Average vehicle green light duration")</MudText>
            </MudPaper>
        </MudItem>

        <!-- Traffic Light Status -->
        <MudItem xs="12" md="4">
            <MudPaper Elevation="4" Class="pa-4 d-flex flex-column justify-space-between" Style="height:100%">

                <MudText Typo="Typo.h5">Current Light Status</MudText>
                <MudGrid Spacing="2" Class="mt-2">
                    <MudItem xs="2">
                        <MudStack Direction="Direction.column">
                            <MudAvatar Size="Size.Large" Color="@(!vehicleLightIsGreen ? Color.Error : Color.Success)"
                                Icon="@Icons.Material.Filled.PlayArrow" />
                            <MudText Typo="Typo.caption">Vehicles</MudText>
                        </MudStack>
                    </MudItem>
                    <MudItem xs="6">
                        <MudStack Direction="Direction.column">
                            <MudAvatar Size="Size.Large" Color="@(vehicleLightIsGreen ? Color.Error : Color.Success)" Icon="@Icons.Material.Filled.Pause" />
                            <MudText Typo="Typo.caption">Pedestrians</MudText>
                        </MudStack>
                    </MudItem>
                </MudGrid>
            </MudPaper>
        </MudItem>
    </MudGrid>
    <MudGrid>
        <MudItem xs="12" md="7">
            <MudPaper Elevation="4" Class="mt-4 pa-4">
                <MudChart ChartType="ChartType.Bar" ChartSeries="@_series" @bind-SelectedIndex="_index"
                    XAxisLabels="@_xAxisLabels" Width="100%" Height="350px" AxisChartOptions="_axisChartOptions">
                </MudChart>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" md="5">
            <MudPaper Elevation="4" Class="mt-4 pa-4">
                <MudChart ChartType="ChartType.Pie" InputData="@data" @bind-SelectedIndex="_pieIndex"
                    InputLabels="@labels" Width="100%" Height="350px" />
            </MudPaper>
        </MudItem>
    </MudGrid>

</MudContainer>
@code {
    protected override async Task OnInitializedAsync()
    {
        var sensorData = await sensorService.GetSensorDataAsync();
        CalculatePieChartData(sensorData);
        CalculateBarChartData(sensorData);
        CalculateAverageDuration(sensorData);
        
        // Connect to MQTT and subscribe to traffic light updates
        try
        {
            await mqttService.ConnectAsync();
            await mqttService.SubscribeAsync("traffic/light");

        }catch(Exception ex){
            Console.WriteLine($"MQTT subscription failed: {ex.Message}");

        }
        mqttService.OnMessageReceived += (payload) =>
        {
            Console.WriteLine($"MQTT Message received on topic  {payload}");
            InvokeAsync(StateHasChanged); // Update UI when MQTT message received
        };
        // Subscribe to MQTT events for real-time updates
        mqttService.OnVehicleLightChanged += (isGreen) =>
        {
            vehicleLightIsGreen = isGreen;
            InvokeAsync(StateHasChanged); // Update UI when MQTT message received
        };
    }

    private bool vehicleLightIsGreen = false;

    private double[] data = new double[2];
    private int _index = -1; //default value cannot be 0 -> first selectedindex is 0.
    private int _pieIndex = -1; //for pie chart
    private string[] labels = { "Vehicles", "Pedestrians" };

    // Added fields for binding in the UI
    private double averageVehicleDuration = 0;
    private double averagePedestrianDuration = 0;

    private void CalculateAverageDuration(List<Utilities.Models.SensorDataModel> sensorData)
{
    double totalGreenDuration = 0;
    double totalRedDuration = 0;
    int greenCycles = 0;
    int redCycles = 0;

    DateTime? greenStartTime = null;
    DateTime? redStartTime = null;

    foreach (var data in sensorData.OrderBy(d => d.Timestamp))
    {
        if (data.SensorValue == "VEHICLE_GREEN")
        {
            // If we were in red, close that cycle
            if (redStartTime != null)
            {
                TimeSpan redDuration = data.Timestamp - redStartTime.Value;
                totalRedDuration += redDuration.TotalSeconds;
                redCycles++;
                redStartTime = null;
            }

            // Start green cycle
            if (greenStartTime == null)
                greenStartTime = data.Timestamp;
        }
        else if (data.SensorValue == "VEHICLE_RED")
        {
            // If we were in green, close that cycle
            if (greenStartTime != null)
            {
                TimeSpan greenDuration = data.Timestamp - greenStartTime.Value;
                totalGreenDuration += greenDuration.TotalSeconds;
                greenCycles++;
                greenStartTime = null;
            }

            // Start red cycle
            if (redStartTime == null)
                redStartTime = data.Timestamp;
        }
    }

     
    averageVehicleDuration = greenCycles > 0 ? Math.Round(totalGreenDuration / greenCycles, 2) : 0;
    averagePedestrianDuration = redCycles > 0 ? Math.Round(totalRedDuration / redCycles, 2) : 0;
}


    private void CalculatePieChartData(List<Utilities.Models.SensorDataModel> sensorData)
    {


        double pedestrianCount = 0;
        double vehicleCount = 0;

        foreach (var data in sensorData)
        {
            if (data.SensorValue == "VEHICLE_GREEN")
            {
                vehicleCount++;
            }
            else if (data.SensorValue == "VEHICLE_RED")
            {
                pedestrianCount++;
            }
        }

        data = new double[] { vehicleCount, pedestrianCount };
    }

    private void CalculateBarChartData(List<Utilities.Models.SensorDataModel> sensorData)
    {
        List<SensorDataModel> dailySensorData = sensorData.Where(d => d.Timestamp.Date == DateTime.Now.Date).ToList();

        // Group data by hour (0-23)
        Dictionary<int, (double vehicles, double pedestrians)> hourlyData = new();

        // Initialize all hours with 0 counts
        for (int hour = 0; hour < 24; hour++)
        {
            hourlyData[hour] = (0, 0);
        }

        // Count sensor events by hour
        foreach (var item in dailySensorData)
        {
            int hour = item.Timestamp.Hour;
            var currentData = hourlyData[hour];

            if (item.SensorValue == "VEHICLE_GREEN")
            {
                hourlyData[hour] = (currentData.vehicles + 1, currentData.pedestrians);
            }
            else if (item.SensorValue == "VEHICLE_RED")
            {
                hourlyData[hour] = (currentData.vehicles, currentData.pedestrians + 1);
            }
        }

        // Update chart series with calculated hourly data
        var vehicleData = new double[24];
        var pedestrianData = new double[24];

        for (int hour = 0; hour < 24; hour++)
        {
            vehicleData[hour] = hourlyData[hour].vehicles;
            pedestrianData[hour] = hourlyData[hour].pedestrians;
        }

        _series = new List<ChartSeries>()
{
new ChartSeries() { Name = "Vehicles", Data = vehicleData },
new ChartSeries() { Name = "Pedestrians", Data = pedestrianData }
};
    }

    private AxisChartOptions _axisChartOptions = new AxisChartOptions()
    {
        XAxisLabelRotation = 30,
        MatchBoundsToSize = true
    };

    private List<ChartSeries> _series = new List<ChartSeries>()
{
new ChartSeries() { Name = "Vehicles", Data = new double[24] },
new ChartSeries() { Name = "Pedestrians", Data = new double[24] }
};

    private string[] _xAxisLabels = { "00:00", "01:00", "02:00", "03:00", "04:00", "05:00", "06:00", "07:00",
"08:00", "09:00", "10:00", "11:00", "12:00", "13:00", "14:00", "15:00", "16:00", "17:00", "18:00",
"19:00", "20:00", "21:00", "22:00", "23:00" };
}